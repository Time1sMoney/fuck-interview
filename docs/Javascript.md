# JavaScript Questions

## 1.有几种数据类型？

基本类型：String,Number,Boolean,Symbol,Bigint,null,undefined

引用类型：Array,Object,Function,Date,RegExp

> 实际上引用类型只有Object，Array,Function,Date,RegExp都是特殊的对象

## 2.什么是变量提升？它导致了哪些问题？

> MDN: 变量提升（Hoisting）被认为是，Javascript 中执行上下文（特别是创建和执行阶段）工作方式的一种认识。在 ECMAScript® 2015 Language Specification 之前的 JavaScript 文档中找不到变量提升（Hoisting）这个词。不过，需要注意的是，开始时，这个概念可能比较难理解，甚至恼人。

>例如，从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。

简而言之，变量提升（Hosting）是指变量和函数的声明会在它们被执行前“提升”到当前作用域的顶部，这意味着可以在声明之前访问这些变量和函数。

**为什么会有变量提升**？ 原因是js执行一段代码需要先编译，编译的过程中会生成对应的执行上下文，变量和函数的声明会保存到其中的变量对象中，代码执行的时候会从当前执行上下文的变量对象逐层往上（词法作用域规则）寻找变量和函数，直到全局执行上下文。

导致的问题：

1. 变量的意外覆盖。如果在变量声明之前使用了同名的变量，由于变量提升，导致其他变量被覆盖，造成逻辑问题。

2. 代码可读性差。

3. 维护困难。

## 3.var、let、const之间的区别？

1. var声明的变量存在变量提升，而let和const则没有。

2. var声明的变量没有块级作用域，let和const声明的变量具有块级作用域。

3. var和let用于声明变量，而const用于声明常量,声明后不可修改（如果是引用类型，地址不可修改，但内部可修改）。

4. var声明的变量可以重复声明，不会报错，而let和const则不行。

> 优先使用const，如果变量需要修改则使用let,尽量避免使用var

## 4.什么是作用域链？

## 5.说一下原型以及原型链？为什么它们被设计在JavaScript中？

## 6.JS中如何实现继承？

## 7.防抖和节流的区别？如何实现？应用场景有哪些？

防抖： 一段时间后执行操作，若这段时间内重复触发，则重新计时。

节流： 一段时间内频繁触发的操作，只执行一次。

## 8.什么是闭包？它有什么作用/应用场景？

> MDN: 闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。

简单来说： 闭包就是可以访问其他作用域中变量的函数。

应用场景：

1. 闭包可以延长变量的生命周期，使其不会被垃圾回收机制回收掉。

2. 借助闭包可以模拟实现变量和方法的私有化。

3. 函数柯里化。

4. 解决循环中的作用域问题：在循环中使用闭包可以解决作用域问题，避免由于作用域链导致的变量共享问题。

```js
const funcArr = []

for(var i = 0; i < 3; i++){
  funcArr[i] = function () {
    console.log(i);
  };
}
funcArr[0]() // 3
funcArr[1]() // 3
funcArr[2]() // 3

```
这里的i是全局变量，循环结束时i=3, 根据作用域链查找，每个函数打印的i都是上层作用域中的i，这不是我们预期的结果。

有两种方法解决：：

```js
// 自执行函数+闭包

const funcArr = []

for(var i = 0; i < 3; i++){
  (function(j){
      setTimeout(funcArr[j] = function () {
        console.log(j);
      }, 0)
  })(i)
}
funcArr[0]() // 3
funcArr[1]() // 3
funcArr[2]() // 3
```
另一种是使用let替换var，let具有块级作用域，三个私有作用域互不干扰。

## 9.如何解决“回调地狱”问题？

## 10.什么是Promise?它的作用是什么？

## 11.什么是生成器（Generator）以及它在异步编程中如何被利用？

## 12.async/await关键字的作用是什么？它们和promise相比有什么优势和不同？

## 13.ES6中引入了对象的解构，它的本质/原理是什么？

## 14.深拷贝和浅拷贝的区别？

## 15.实现深拷贝的方法有哪些？

## 16.for...of和for...in的区别？

**for...in**：一般用于遍历对象的非Symbol**可枚举属性**以及**继承的可枚举属性**（来自原型链）,也就是说它会遍历原型。

**for...of**: 用于遍历**可迭代对象**，只要对象有`Symbol.iterator`属性并实现了相应的`Iterator`就能被遍历。例如内置的Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象等等。

> 因此， Set可以通过使用forEach、for...of、转为数组后遍历三种方式进行遍历。

