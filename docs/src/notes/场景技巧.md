# 场景技巧

## JavaScript 中超过 Number 最大值的数这么处理？

在 JavaScript 中，超过`Number.MAX_VALUE`的数被认为是`Infinity`,而在某些场景下我们需要正确地操作/显示超过`Number.MAX_VALUE`的数，在 ES2020/ES11 之前通常需要借助第三方库来实现，例如`big.js`。

```js
const big = require("big.js");
const x = new big("9007199254740993");
const y = new big("100000000000000000");
const result = x.plus(y);
console.log(result.toString()); // 输出：109007199254740993
```

第二种方案就是借助 ES2020/ES11 引入的新的数据类型`BigInt`，可以用在一个整数字面量后面加 n 的方式来定义一个 `BigInt`。注意，使用该方案需要考虑浏览器的兼容性，如果在不支持的环境中使用，需要使用 polyfill 或者第三方库。

::: tip MDN
`BigInt`是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。`BigInt`可以表示任意大的整数。
:::

```js
const a = 12345678900000000000000n;
```

## 使⽤同⼀个链接，如何实现 PC 打开是 web 应⽤、⼿机打开是⼀个 H5 应⽤？

可以通过根据请求来源（User-Agent）来判断访问设备的类型，然后在服务器端进行适配。

具体实现可以参考以下步骤：

1. 根据 `User-Agent`判断访问设备的类型，例如判断是否为移动设备。可以使用第三方库如`ua-parser-js`进行解析。

2. 如果是移动设备，可以返回⼀个 H5 页面或接口数据。

3. 如果是 PC 设备，可以返回⼀个 web 应用页面或接口数据。

## 如何解决⻚⾯请求接口大规模并发问题？

接口大规模并发包含了接口并发和前端资源请求并发，解决方案参考如下：

1. 后端优化：可以对接口进⾏优化，采用缓存技术，对数据进行预处理，减少数据库操作等。使用集群技术，将请求分散到不同的服务器上，提高并发量。另外可以使用反向代理、负载均衡等技术，分担服务器压力。

2. 做 BFF 聚合：把所有首屏需要依赖的接口，利用服务中间层聚合为一个接口。

3. CDN 加速：使用 CDN 缓存技术可以有效减少服务器请求压力，提高网站访问速度，接口数据存储在 CDN 缓存服务器可以减少对原始服务器的访问，加速数据传输速度。

4. 使用 websocket 建立一个持久的连接，避免反复连接请求。websocket 可以实现双向通信，大大降低服务区响应时间。

5. 使用 HTTP/2.0 及以上版本，利用多路复用。

6. 使用浏览器缓存技术：强缓存、协商缓存、离线缓存、[Service Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)缓存等。

7. 聚合一定量的静态资源，比如对图片进行雪碧图处理，多张图片只下载一张即可。

8. 采用微前端架构：只对当前访问的页面的静态资源进行下载，而不是下载整站的静态资源。

9. 使用 SSR 技术：在服务端组织页面结构和处理数据并返回页面渲染，避免客户端渲染完成后进行额外的数据请求和下载。

## 如何设计一个全站的请求耗时统计工具？

代码层面可以统计请求耗时的方案如下：

1. [Performance API](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance)是浏览器 Web API 的一种，用于测量网页性能。通过它可以获取页面各个阶段的时间、资源加载时间等，其中[PerformanceResourceTiming API](https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceResourceTiming)可以获取到每个资源的加载时间，从而计算出请求耗时。

2. `XMLHttpRequest`的`load`事件：在发送`XMLHttpRequest`请求时注册`load`事件，在请求完成时执行回调函数，从而计算出请求耗时。

3. `fetch`的`Performance API`：类似于`XMLHttpRequest`，通过该 API 获取请求耗时。

4. 自定义封装的请求函数，在请求开始和结束时记录时间，从而计算耗时。

个人推荐使用第一种方案，这是浏览器提供的 API，功能强大，结果准确。以下是单个请求的耗时计算参考：

```js
performance.mark("fetch start");

fetch("https://json.myservices.com/v1/test")
  .then((res) => res.json())
  .then((res) => {
    performance.mark("fetch end");
    const info = performance.measure(
      "fetch duration",
      "fetch start",
      "fetch end"
    );

    console.log(info.duration);

    // 发送到服务器等其他操作
  });
```
