# 场景技巧

## JavaScript 中超过 Number 最大值的数这么处理？

在 JavaScript 中，超过`Number.MAX_VALUE`的数被认为是`Infinity`,而在某些场景下我们需要正确地操作/显示超过`Number.MAX_VALUE`的数，在 ES2020/ES11 之前通常需要借助第三方库来实现，例如`big.js`。

```js
const big = require("big.js");
const x = new big("9007199254740993");
const y = new big("100000000000000000");
const result = x.plus(y);
console.log(result.toString()); // 输出：109007199254740993
```

第二种方案就是借助 ES2020/ES11 引入的新的数据类型`BigInt`，可以用在一个整数字面量后面加 n 的方式来定义一个 `BigInt`。注意，使用该方案需要考虑浏览器的兼容性，如果在不支持的环境中使用，需要使用 polyfill 或者第三方库。

::: tip MDN
`BigInt`是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。`BigInt`可以表示任意大的整数。
:::

```js
const a = 12345678900000000000000n;
```

## 使⽤同⼀个链接，如何实现 PC 打开是 web 应⽤、⼿机打开是⼀个 H5 应⽤？

可以通过根据请求来源（User-Agent）来判断访问设备的类型，然后在服务器端进行适配。

具体实现可以参考以下步骤：

1. 根据 `User-Agent`判断访问设备的类型，例如判断是否为移动设备。可以使用第三方库如`ua-parser-js`进行解析。

2. 如果是移动设备，可以返回⼀个 H5 页面或接口数据。

3. 如果是 PC 设备，可以返回⼀个 web 应用页面或接口数据。

## 如何解决⻚⾯请求接口大规模并发问题？

接口大规模并发包含了接口并发和前端资源请求并发，解决方案参考如下：

1. 后端优化：可以对接口进⾏优化，采用缓存技术，对数据进行预处理，减少数据库操作等。使用集群技术，将请求分散到不同的服务器上，提高并发量。另外可以使用反向代理、负载均衡等技术，分担服务器压力。

2. 做 BFF 聚合：把所有首屏需要依赖的接口，利用服务中间层聚合为一个接口。

3. CDN 加速：使用 CDN 缓存技术可以有效减少服务器请求压力，提高网站访问速度，接口数据存储在 CDN 缓存服务器可以减少对原始服务器的访问，加速数据传输速度。

4. 使用 websocket 建立一个持久的连接，避免反复连接请求。websocket 可以实现双向通信，大大降低服务区响应时间。

5. 使用 HTTP/2.0 及以上版本，利用多路复用。

6. 使用浏览器缓存技术：强缓存、协商缓存、离线缓存、[Service Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)缓存等。

7. 聚合一定量的静态资源，比如对图片进行雪碧图处理，多张图片只下载一张即可。

8. 采用微前端架构：只对当前访问的页面的静态资源进行下载，而不是下载整站的静态资源。

9. 使用 SSR 技术：在服务端组织页面结构和处理数据并返回页面渲染，避免客户端渲染完成后进行额外的数据请求和下载。

## 如何设计一个全站的请求耗时统计工具？

代码层面可以统计请求耗时的方案如下：

1. [Performance API](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance)是浏览器 Web API 的一种，用于测量网页性能。通过它可以获取页面各个阶段的时间、资源加载时间等，其中[PerformanceResourceTiming API](https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceResourceTiming)可以获取到每个资源的加载时间，从而计算出请求耗时。

2. `XMLHttpRequest`的`load`事件：在发送`XMLHttpRequest`请求时注册`load`事件，在请求完成时执行回调函数，从而计算出请求耗时。

3. `fetch`的`Performance API`：类似于`XMLHttpRequest`，通过该 API 获取请求耗时。

4. 自定义封装的请求函数，在请求开始和结束时记录时间，从而计算耗时。

个人推荐使用第一种方案，这是浏览器提供的 API，功能强大，结果准确。以下是单个请求的耗时计算参考：

```js
performance.mark("fetch start");

fetch("https://json.myservices.com/v1/test")
  .then((res) => res.json())
  .then((res) => {
    performance.mark("fetch end");
    const info = performance.measure(
      "fetch duration",
      "fetch start",
      "fetch end"
    );

    console.log(info.duration);

    // 发送到服务器等其他操作
  });
```

## 如何实现大文件上传？

**分片上传**: 在文件上传的实际应用场景中，如果需要上传的文件大小过大就会导致请求时间非常地长，可能会出现超时的情况，并且失败之后有需要重新上传，用户体验非常不好。在众多成熟的落地产品中，对于大文件上传往往会先对文件进行分片处理，然后依次将文件分片上传到服务器，等所有的分片上传完毕后，服务器对分片进行一个合并操作得到原始的文件。

**断点续传**: 在分片上传的过程中如果出现网络问题或者手动暂停导致上传中断，在重新开始上传后对于已经上传的文件分片无需再进行操作，只需要对未上传的分片接着上传，这就需要知道哪些文件分片没有被上传,哪些已经上传，也就是说每一个文件分片需要一个具体标识。我们一般会使用文件 hash 来作为文件标识，而文件 hash 可以使用 md5 算法计算得到（可使用第三方库，例如`spark-md5`）。对于上传成功的分片，可以将其 hash 保存在`localStorage`中,也可以由服务端保存，提供一个新的接口在重新上传时返回已经上传的文件分片的 hash 数组，在重新上传文件时检查分块的 hash 是否在已上传 hash 数组中，是则跳过。

::: tip
如果需要整个文件的 hash，不推荐一次性计算，可以使用增量计算，利用`spark-md5`的`append()`方法。
:::

::: code-group

```ts [文件分片]
function createChunk(file: File, chunkSize: number) {
  const result = [];
  for (let i = 0; i < file.size; i += chunkSize) {
    result.push(file.slice(i, i + chunkSize));
  }
  return result;
}
```

```ts [计算整个文件hash]
import SparkMD5 from "spark-md5";

function hash(chunks: Blob[]) {
  const spark = new SparkMD5();
  return new Promise((resolve) => {
    function _read(i) {
      if (i >= chunks.length) {
        resolve(spark.end());
        return;
      }
      const blob = chunks[i];
      const reader = new FileReader();
      reader.onload = (e) => {
        const bytes = e.target.result;
        spark.append(bytes);
        _read(i + 1);
      };
      reader.readAsArrayBuffer(blob);
    }
    _read(0);
  });
}
```

:::

## H5 如何解决移动端适配问题?

1. 使用`viewport meta`标记，设置其`content`属性来控制页面的缩放比例和宽度以适配不同的设备。

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```

2. 使用 CSS3 媒体查询做响应式布局。

```css
@media screen and (min-width: 768px) {
  font-size: 12px;
}
```

3. 使用相对像素单位 rem 替代绝对像素单位 px：rem 大小是相对于文档根节点的字体大小，配合 CSS 媒体查询以适配不同设备。

## 如何实现一个网页的加载进度条？

实现一个网页加载进度条的关键在于如何获取静态资源的加载状态，然后根据这些状态动态修改进度条。

1. 获取页面静态资源的加载状态可以借助`window.performance`对象来监听所有静态资源的加载，例如：

```js
const resources = window.performance.getEntriesByType("resource");
const totalResources = resources.length;
let loadedResources = 0;
resources.forEach((resource) => {
  if (resource.initiatorType !== "xmlhttprequest") {
    // 排除 AJAX 请求
    resource.onload = () => {
      loadedResources++;
      const progress = Math.round((loadedResources / totalResources) * 100);
      updateProgress(progress);
    };
  }
});
function updateProgress() {
  // 更新进度条
}
```

2. 实现一个进度条，可以使用 HTML5 提供的`<progress>`元素或借助第三方库`nprogress`等。

::: code-group

```html [原生progress标签]
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>原生进度条</title>
  </head>
  <body>
    <progress id="progressBar" value="0" max="100" />
    <script>
      const progressBar = document.getElementById("progressBar");
      window.addEventListener("load", () => {
        progressBar.value = 100;
      });
      document.addEventListener("readystatechange", (e) => {
        if (e.target.readyState === "loading") {
          progressBar.value = 50;
        } else if (e.target.readyState === "interactive") {
          progressBar.value = 90;
        } else {
          progressBar.value = 100;
        }
      });
    </script>
  </body>
</html>
```

```js [使用nprogress]
// 初始化 nprogress
NProgress.configure({ showSpinner: false });
// 监听⻚⾯加载事件
window.addEventListener("load", () => {
  NProgress.done();
});
// 监听资源加载事件
document.addEventListener("readystatechange", () => {
  if (document.readyState === "interactive") {
    NProgress.start();
  } else if (document.readyState === "complete") {
    NProgress.done();
  }
});
```

:::

## 常见的图片懒加载的方案有哪些？

图片懒加载可以延迟图片的加载，只在图片即将进入视口时才进行加载，对于有大量图片的页面可以大大减少页面的加载时间，降低带宽，提升用户体验。例如淘宝商品页、小红书、外卖平台等等，基本上都是用户滚动时进行图片懒加载。

1. 使用[IntersectionObserver API](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)，它可以异步检查文档元素与祖先元素或视口的交叉状态，利用这个特性可以实现图片在即将进入视口时加载并作其他处理。

```js
const images = document.querySelectorAll(".image");
const observer = new IntersectionObserver((entries, ob) => {
  entries.forEach((entry) => {
    console.log(entry);
    if (entry.isIntersecting) {
      entry.target.src = entry.target.dataset.src;
      ob.unobserve(entry.target); // 取消监听该元素
    }
  });
});
images.forEach((item) => observer.observe(item));
```

2. 自定义事件监听器。需注意的是，应该避免在滚动事件处理函数中频繁触发图片加载，这会影响性能，而应在滚动停止时触发。

```js
function lazyLoad() {
  const images = document.querySelectorAll(".image");
  const scrollTop = window.pageYOffset;
  images.forEach((img) => {
    if (img.offsetTop < window.innerHeight + scrollTop) {
      img.src = img.dataset.src;
    }
  });
}
let lazyLoadThrottleTimeout;
document.addEventListener("scroll", function () {
  if (lazyLoadThrottleTimeout) {
    clearTimeout(lazyLoadThrottleTimeout);
  }
  lazyLoadThrottleTimeout = setTimeout(lazyLoad, 20);
});
```

无论哪种方法，都需要为懒加载的图片添加占位符，避免出现布局错乱。

## 函数式编程了解多少？

函数式编程是一种编程范式，它将程序看作是一系列函数的组合，函数是基本单位。特点如下：

1. 纯函数：函数的输出只取决于输入，没有副作用（不会修改外部的变量或状态），因此对于同样的输入永远只能得到同样的输出。纯函数可以有效地避免副作用和竟态条件，使得代码更加可靠和易于调试。

2. 不可变性：在函数式编程中，数据通常是不可变的，也就是不允许内部修改。这样可以避免富副作用，提高程序可靠性。

3. 函数组合：不同的函数可以组合成新的复杂的函数，从而提高代码的复用性。

4. 高阶函数：高阶函数是指可以接收其他函数作为参数或返回其他函数的函数。应用场景包括函数柯里化和函数组合等等。

5. 惰性计算：惰性计算是指在必要的时候才计算或执行函数，而不是在每个可能的执行路径上都执行，这样可以提高性能。

通过上述的特性可以得出函数式编程的优势：**易于理解维护、更高的可靠性、更好的测试性、避免并发问题、提高代码复用**。

## 如何判断一个 DOM 元素是否在可视区域内？

1. 使用元素对象的`getBoundingClientRect`方法获取该元素的大小以及相对于视口的位置。包括`top`,`right`,`bottom`,`left`四个属性，依据这四个属性可以判断该元素是否在视口内。

![getBoundingClientRect](../assets/getBoundingClientRect.png)

```js
function isViewPort(element) {
  const rect = element.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <=
      (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}
```

2. 使用`IntersectionObserver`API 来监听元素与视口的交叉情况。具体使用方法不多赘述。

## 如何通过设置失效时间清除本地存储的数据？

思路：在将数据存入本地`localStorage`或`sessionStorage`中时，同时设置一个过期时间（时间戳或者特定日期），在读取数据时检查时间是否超过过期时间，如果超过则认为数据失效，清楚数据。

```js
function setLocalStorageData(key, data, expiration) {
  localStorage.setItem(
    key,
    JSON.stringify({
      data,
      expiration,
    })
  );
}

function getLocalStorageData(key) {
  let item = localStorage.getItem(key);
  if (item) {
    item = JSON.parse(item);
    if (item.expiration && new Date().getTime() > item.expiration) {
      localStorage.removeItem(key);
      return null;
    }
    return item.data;
  }
  return null;
}
```

## SPA 应用为什么都会提供 hash 路由？有什么好处？

SPA 通常使用 hash 路由的方式实现页面导航和路由，这种方式将路由信息存储在 URL 的标识片段中，例如`https://exmaple.com/#/home`，之所以使用 hash 路由的方式，主要得益于：

1. hash 路由的兼容性非常好，基本市面上所有的主流浏览器都支持，且包括一些旧版本的浏览器。

2. hash 路由实现简单，只需要在页面中监听`hashchange`事件，然后根据不同的 hash 值加载对应的内容，这种方式不需要服务器端的额外配置，在初始页面渲染后一切都由客户端控制。

3. 防止页面刷新。使用 hash 路由可以完全防止页面的刷新，因为 hash 路由只改变 URL 标识符，不会引起整个页面的重新加载，所以用户在不同页面之间切换时不会丢失当前页面的状态。

4. 支持前进后退。由于 hash 路由不会引起页面的刷新，因此可以方便地支持浏览器地前进和后退。

5. 无需服务器端配置，完全由客户端控制。

::: tip
hash 路由也存在一些局限性，例如 URL 不够美观，不利于 SEO 等等，而 HTML5 带来的 History API 很好地解决了第一个问题，对于注重 SEO 的页面可以考虑使用 SSR。
:::

## 单点登录是什么？它的流程是怎么样的？

单点登录(SSO)⼀般都需要⼀个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录后，passport 将会颁发⼀个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。

流程如下：

1. 用户访问系统 A 的受保护资源，系统 A 发现用户未登录，跳转到 SSO 认证中心，并将自己的 url 作为参数。

2. SSO 认证中心发现用户没有登录，跳转到登录页面。

3. 用户提交登录信息，SSO 认证中心校验，通过后创建用户和认证中心的会话（全局会话），同时创建授权令牌。

4. 认证中心带着令牌跳转回系统 A。

5. 系统 A 拿着令牌去认证中心校验令牌，有效则注册系统 A。

6. 系统 A 使用该令牌创建和用户的会话（局部会话），返回受保护资源。

7. 用户访问系统 B 受保护资源，系统 B 发现用户未登录，跳转至认证中心，并将自己的 url 作为参数。

8. 认证中心发现用户已登录，跳转回系统 B，并附带上令牌。

9. 系统 B 拿到令牌，去认证中心验证令牌是否有效，有效则注册系统 B。

10. 系统 B 使用令牌创建与用户的会话（局部会话），返回受保护资源。

## 用户访问页面白屏的原因是什么？如何排查？

访问页面白屏有多种原因，排查方向如下：

1. 网络原因：用户自身网络可能存在问题而无法正确加载内容，对于这种情况应在上线之前针对性地进行不同网络状况的测试。

2. 前端代码问题：页面代码存在错误和异常，导致页面无法正确渲染，可以检查控制台，针对错误快速锁定问题代码所在。对于 React 项目需要做好错误边界的处理，提升用户体验，亦便于更快锁定问题。

3. 服务端问题： 服务端未正确响应用户请求导致页面无法加载。可以检查服务器运行状态、日志和错误信息。

4. 浏览器兼容性问题： 不同的浏览器对于代码的支持程度不一样，可能导致一些 API 无法使用和代码执行错误，对于该问题需要开发者在编写代码时对于可能存在兼容性问题的 API 做`polyfill`处理。

5. 第三方资源问题： 如果页面引用的第三方资源出现问题而无法加载也可能会导致页面白屏，可以检查网络请求是否正常，例如在 Chrome 中查看`Network`选项卡查看哪些资源加载失败。

6. 缓存问题：浏览器中可能保存了旧版本的页面或资源从而导致新版本页面无法正常加载。

7. 其他原因：安全策略、跨域问题、DNS 解析问题等都可能引发页面白屏。

不管是那种问题，都需要根据具体情况具体分析和逐步排查，结合浏览器的开发者工具以辅助定位问题。为了避免在生产环境出现不必要的异常，项目上线之前必须做好测试工作，充分考虑不同用户不同场景的情况。

## 
